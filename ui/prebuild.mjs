import fs from 'node:fs'
import path from 'node:path'
import { exec } from 'node:child_process'
//import orderBy from 'lodash.orderby'
import set from 'lodash.set'

/*
 * Shared header to include in written .mjs files
 */
export const header = `/*
 * This file was auto-generated by the prebuild script
 * Any changes you make to it will be lost on the next (pre)build.
 */
`

/*
 * Strips quotes from the start/end of a string
 */
const stripQuotes = (str) => {
  str = str.trim()
  if (str.slice(0, 1) === '"') str = str.slice(1)
  if (str.slice(-1) === '"') str = str.slice(0, -1)

  return str.trim()
}

/*
 * This is the fast and low-tech way to some frontmatter from all files in a folder
 */
const loadFolderFrontmatter = async (key, pages = {}) => {
  /*
   * Figure out what directory to spawn the child process in
   */
  const cwd = await path.resolve(process.cwd(), 'pages', 'docs')
  /*
   * When going through a small number of files in a flat directory (eg. blog posts) a
   * recursive grep through all files is faster.
   * But the biggest task is combing through all the documentation and for this
   * it's much faster to first run find to limit the number of files to open
   */
  const cmd = `find . -type f -name "*.mdx" -exec grep "^${key}:" -ism 1 {} +`
  const grep = exec(cmd, { cwd, maxBuffer: 2048 * 1024 }, (error, stdout, stderr) => {
    if (error) {
      console.error(`exec error: ${error} - ${stderr}`)
      return
    }

    return stdout
  })

  /*
   * Stdout is buffered, so we need to gather all of it
   */
  let stdout = ''
  for await (const data of grep.stdout) stdout += data

  /*
   * Turn all matches into an array
   */
  const matches = stdout.split('\n').map((match) =>
    match
      .slice(2)
      .split(':')
      .filter((val, i) => i !== 1)
      .map((val) => (val.slice(-4) === '.mdx' ? val.slice(0, -4).trim() : val.trim()))
      .map((val, i) => (i === 0 ? `docs/${val}` : val))
      .map((val, i) => (i === 0 && val.slice(-6) === '/index' ? val.slice(0, -6) : val))
      .filter((slug) => slug !== 'index')
  )

  /*
   * Turns matches into structured data
   */
  for (let match of matches) {
    if (match.length === 2) {
      if (typeof pages[match[0]] === 'undefined') pages[match[0]] = {}
      pages[match[0]][key] = match[1]
    }
  }

  return pages
}

/*
 * Merges in order key on those slugs that have it set
 */
const mergeDocs = (pages) => {
  const navs = {}
  for (const slug of Object.keys(pages).sort())
    set(navs, slug.split('/'), {
      t: pages[slug].title,
      o: (pages[slug].order || '') + pages[slug].title,
    })

  return navs
}

/*
 * Loads all docs files, titles and order
 */
const loadDocs = async (site) => {
  const pages = await loadFolderFrontmatter('title')
  await loadFolderFrontmatter('order', pages)

  return mergeDocs(pages)
}

/*
 * Write out prebuild files
 */
const writeNavs = async (navs) => {}

/*
 * Main method that does what needs doing for the docs
 */
export const prebuildDocs = async () => {
  const navs = await loadDocs()

  fs.writeFileSync(
    path.resolve('.', 'prebuild', `docs-navs.mjs`),
    `${header}export const docsNavs = ${JSON.stringify(navs)}`
  )
}

prebuildDocs()
